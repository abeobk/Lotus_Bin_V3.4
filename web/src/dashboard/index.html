<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preload" href="../../css/font-awesome.min.css" as="style"
        onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="../../css/theme.css">
    <script src="../../script/clusterize.min.js"></script>
    <script src="../../script/vue.global.prod.js"></script>
    <script src="../../script/chart.js"></script>
    <script src="../../script/utils.js"></script>
    <script src="../../script/api.js"></script>
</head>

<!-- mounting point of the app -->

<body id="app">
    <!-- Navigation bar -->
    <nav id="nav-bar">
        <button class="control-button" @click="onSettingsButtonClick"><i class="fa fa-cog"></i></button>
        <button class="control-button" v-show="!isAutoMode" @click="onModelButtonClick"> <i
                class="fa fa-cube"></i></button>
        <button class="theme-button" style="margin-left:auto" @click="this.toggleTheme()"><i
                class="fa fa-adjust"></i></button>
    </nav>

    <!-- Result panel -->
    <div id="result-panel" class="result-panel" style="display: flex; flex-direction: column;">
        <!-- Cycle info panel -->
        <div class="cycle-info-container">
            <div class="cycle-info-card">
                <span class="cycle-info-label">MODEL</span>
                <span class="cycle-info-value">{{crrModelName}}</span>
            </div>

            <div class="cycle-info-card">
                <span class="cycle-info-label">BODY / VIN NO</span>
                <span class="cycle-info-value">{{crrVinNo}}</span>
            </div>

            <div class="cycle-info-card">
                <span class="cycle-info-label">SEQ NO</span>
                <span class="cycle-info-value">{{crrSeqNo}}</span>
            </div>
        </div>

        <!-- Result table -->
        <div v-for="(table, tblIndex) in resultData" :key="'res-table-'+tblIndex">
            <table class="result-table">
                <thead>
                    <th v-for="(col,colIndex) in table.cols" :key="'res-table-'+colIndex">{{ col }}</th>
                </thead>
                <tbody>
                    <tr v-for="(row,rowIndex) in table.rows" :key="'res-table-row-'+rowIndex">
                        <td v-for="(col,colIndex) in table.cols" :key="'res-table-row-'+rowIndex+'-'+colIndex"
                            :class="!row ? '' : (colIndex===0 ? 'res-text '+(row['ok']?'ok':'ng'):!row[col+'_ok']?'res-text ng':'')">
                            {{ !row ? '-' : row[col] }}
                            <i class="fa " :class="row['ok']?'fa-check-circle':'fa-times-circle'"
                                v-if="row&&colIndex===0"></i>
                        </td>
                    </tr>
            </table>
        </div>
        <div style=" margin-top:auto">
        </div>
    </div>

    <!-- Tab panel -->
    <div id="tab-panel" class="panel tab-panel">
        <h3 class="section-title">{{crrTabTitle}}</h3>
        <button class="control-button" :class="{active: crrTab===this.TAB.HISTORY}"
            @click="this.activateTab(this.TAB.HISTORY);console.log('History view')" style="margin-left: auto;"><i
                class="fa fa-table"></i></button>
        <button class="control-button" :class="{active: crrTab===this.TAB.PLC}"
            @click="this.activateTab(this.TAB.PLC);console.log('PLC map view')"><i class="fa fa-microchip"></i></button>
        <button class="control-button" :class="{active: crrTab===this.TAB.ANALYTICS}"
            @click="this.activateTab(this.TAB.ANALYTICS);console.log('Stats view')"><i
                class="fa fa-chart-pie"></i></button>
        <button class="control-button" :class="{active: crrTab===this.TAB.LOG}"
            @click="this.activateTab(this.TAB.LOG);console.log('Log view')"><i class="fa fa-list"></i></button>
        <!-- <button class="control-button" v-show="!isAutoMode"
            @click="this.activateTab(this.TAB.MODEL);console.log('Model view')"> <i class="fa fa-cube"></i></button> -->
    </div>

    <!-- Main panel -->
    <div id="main-panel" class="panel main-panel">
        <!-- history -->
        <div class="main-panel" v-show=" crrTab===TAB.HISTORY">
            <div class="counter-card-row">
                <div class="counter-card">
                    <div class="counter-label-row">
                        <span class="counter-label ok"><i class="fa fa-check-circle"></i> OK</span>
                        <span class="counter-percent">{{(okCount / Math.max(1,okCount + ngCount) *
                            100).toFixed(2)}}%</span>
                    </div>
                    <span class="counter-value">{{okCount}}</span>
                </div>
                <div class="counter-card">
                    <div class="counter-label-row">
                        <span class="counter-label ng"><i class="fa fa-times-circle"></i> NG</span>
                        <span class="counter-percent">{{(ngCount / Math.max(1,okCount + ngCount) *
                            100).toFixed(2)}}%</span>
                    </div>
                    <span class="counter-value">{{ngCount}}</span>
                </div>
            </div>
            <div class="chart-container">
                <canvas class="hourly-chart" id="hourlyChart"> </canvas>
            </div>

            <!-- History table -->
            <div class="history-table-container">
                <table class="history-table" style="margin:0;">
                    <thead>
                        <th v-for="col in historyCols" :key="'hist-table-'+col">{{ col }}</th>
                    </thead>
                </table>
                <div id="history-clusterize-scroll" class="history-table-scroll">
                    <table class="history-table" style="margin:0;">
                        <tbody id="history-clusterize-content">
                            <!-- Clusterize will inject rows here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>


        <!-- plc -->
        <div class="plc-container" v-show="crrTab===TAB.PLC">
            <div class="plc-column">
                <div class="plc-header">
                    <span class="io-badge" :class="{ active: readFlashTimeout}">R</span>
                    <span>INPUT</span>
                </div>
                <div id="plc-input" class="plc-column-content">
                    <div class="pin-row" v-for="pin in plcInputs" :key="pin.Name" @dblclick="onInputPinDblClick(pin)">
                        <span class="pin-badge"
                            :class="{ active: pin.isActive, err: pin.isErr, manual: pin.isManual }">{{pin.Index}}</span>
                        <span>{{pin.Text !== "" ? pin.Text : pin.Name}}</span>
                    </div>
                </div>
            </div>

            <div class="plc-column">
                <div class="plc-header">
                    <span class="io-badge" :class="{ active: writeFlashTimeout}">W</span>
                    <span>OUTPUT</span>
                </div>
                <div id="plc-output" class="plc-column-content">
                    <div class="pin-row" v-for="pin in plcOutputs" :key="pin.Name" @dblclick="onOutputPinDblClick(pin)">
                        <span class="pin-badge"
                            :class="{ active: pin.isActive, err: pin.isErr, manual: pin.isManual }">{{pin.Index}}</span>
                        <span>{{pin.Text !== "" ? pin.Text : pin.Name}}</span>
                    </div>
                </div>
            </div>
        </div>


        <!-- analytics-->
        <div class="main-panel" v-show="crrTab===TAB.ANALYTICS">
            <div class="chart-container" style="margin-top:0.5rem; height:40%">
                <canvas class="pie-chart" id="analyticPieChart"> </canvas>
            </div>
            <div class="chart-container" style="margin-top:0.5rem;margin-bottom:0.5rem;height:calc(60% - 1.5rem)">
                <canvas class="hourly-chart" id="analyticHourlyChart"> </canvas>
            </div>
        </div>

        <!-- log -->
        <div class="log-container" id="log-clusterize-scroll" v-show="crrTab===TAB.LOG">
            <div id="log-clusterize-content">
                <!-- Clusterize will inject rows here -->
            </div>
        </div>

        <!-- make model -->
        <!-- <div class="main-panel" v-show="crrTab===TAB.MODEL" style="padding:1rem; overflow:auto;">
            <div class="row-div">
                <button title="Clear data" class="control-button" @click="onMakeModelClear()"><i class="fa fa-trash"></i></button>
                <button title="Save data" class="control-button" @click="onMakeModelSave()" style="margin-left:auto"><i class="fa fa-save"></i></button>
            </div>
        </div> -->
    </div>

    <!-- Mini log -->
    <div id="mini-log" class="panel mini-log">
        <span class="log-level" :class="'log-'+lastlog.level" v-show="crrTab!==1">{{lastlog.level}}</span>
        <span class="log-content-mini" v-show="crrTab!==1">{{lastlog.message}}</span>
        <span class="log-counter" style="margin-left:auto" @click="setLogFilterLevel(1);" v-show="crrTab===1">
            <i class="fa fa-list"></i>{{logCount}}</span>
        <span class="log-counter warn" @click="setLogFilterLevel(2);" v-show="crrTab===1">
            <i class="fa fa-exclamation-triangle"></i>{{warnLogCount}}</span>
        <span class="log-counter error" @click="setLogFilterLevel(3);" v-show="crrTab===1">
            <i class="fa fa-times-circle"></i>{{errLogCount}}</span>
        <span class="log-counter" @click="setLogFilterLevel(0);debugCnt++;" v-show="crrTab===1">
            <i class="fa fa-bug"></i></span>
        <!-- NG only filter -->
        <button class="filter-button" :class="{ active: showNGOnly }" @click="showNGOnly^=true" v-show="crrTab===0"
            style="margin-left:auto">
            <i class="fa fa-filter"></i></button>
    </div>

    <!-- Vue App Script -->
    <script>
        const { createApp } = Vue;
        const app = createApp({
            // App data
            data() {
                return {
                    title: "Dashboard",
                    TAB: { HISTORY: 0, LOG: 1, PLC: 2, ANALYTICS: 3, MODEL: 4 },
                    tabTitles: ['Result History', 'System Logs', 'PLC I/O', 'Analytics', 'Make Model'],
                    crrTab: 0,
                    isAutoMode: false,
                    //cycle info
                    crrModelName: "Model_XYZ",
                    crrVinNo: "ABC123545",
                    crrSeqNo: "0123",
                    //logs
                    logCount: 0,
                    warnLogCount: 0,
                    errLogCount: 0,
                    logClusterize: null,
                    logScrollArea: null,
                    logInteractTimeout: null,
                    logPauseAutoScroll: false,
                    logFilterLevel: 1,//0=all,1=log,2=warn,3=error
                    logs: [],
                    lastlog: { level: "LOG", message: "log entry", timestamp: new Date() },
                    logFilterTimeout: null,
                    //plcs
                    plcInputs: [],
                    plcOutputs: [],
                    readFlashTimeout: null,
                    writeFlashTimeout: null,
                    plcRecentChanges: new Map(),
                    //chart
                    showNGOnly: false,
                    showNGOnlyTimeout: null,
                    hourlyData: [],
                    //history
                    okCount: 0,
                    ngCount: 0,
                    historyCols: [],
                    historyData: [],
                    historyClusterize: null,
                    historyScrollArea: null,
                    //result
                    resultData: [],
                    //make model
                    makeModelLayout: null,
                    //debug
                    debugCnt: 0,
                    debugT0: 0,
                }
            },

            // Computed properties
            computed: {
                crrTabTitle() {
                    return this.tabTitles[this.crrTab] || "Unknown";
                },
                filteredHistoryData() {
                    if (this.showNGOnly) {
                        return this.historyData?.filter(row => row.result.toLowerCase() === 'ng');
                    }
                    return this.historyData;
                }
            },
            //other methods
            methods: {
                // Toggle between light and dark themes
                toggleTheme() {
                    const body = document.body;
                    if (body.getAttribute('data-theme') === 'light') {
                        body.removeAttribute('data-theme');
                        localStorage.setItem('theme', 'dark');
                    } else {
                        body.setAttribute('data-theme', 'light');
                        localStorage.setItem('theme', 'light');
                    }
                },
                //buttons
                onSettingsButtonClick() {
                    CSharpUtils.sendMessage({ type: 'setting_button_click' });
                },
                onModelButtonClick() {
                    CSharpUtils.sendMessage({ type: 'model_button_click' });
                },

                //activate specific tab
                activateTab(tabIndex) {
                    this.crrTab = tabIndex;
                    // if (this.crrTab == this.TAB.MODEL) {
                    //     CSharpUtils.sendMessage({ type: 'get_make_model_layout' });
                    //     // return;//dont save model tab
                    // }
                    localStorage.setItem('crrTab', tabIndex);
                },

                //LOGVIEW
                // Initialize Clusterize.js
                initLogClusterize() {
                    if (this.logClusterize) return;
                    this.logClusterize = new Clusterize({
                        rows: [],
                        scrollId: 'log-clusterize-scroll',
                        contentId: 'log-clusterize-content'
                    });
                },

                //add log entry to the log view
                addLogEntry(entry) {
                    if (!entry) return;
                    if (!this.logs) return;
                    const level = entry['l'].toUpperCase();
                    const timestamp = entry['t'];
                    const message = entry['m'];
                    this.logCount++;
                    if (level == "WARN") this.warnLogCount++;
                    if (level == "ERROR") this.errLogCount++;
                    // Fill with initial logs if any
                    if (this.logs.length > 1500) {
                        this.logs = this.logs.slice(-1000);
                    }

                    this.logs.push({
                        level: level,
                        content: `<div class="log-row">
                            <span class="log-timestamp">${timestamp.split(' ')[1]}</span>
                            <span class="log-level log-${level}">${level}</span>
                            <span class="log-content">${message}</span>
                        </div>`});

                    this.lastlog = { level: level, message: message, timestamp: timestamp };
                },

                //log filter level
                setLogFilterLevel(level) {
                    this.logFilterLevel = level;
                    this.logPauseAutoScroll = false;
                    this.logScrollArea.scrollTop = this.logScrollArea.scrollHeight;
                },
                //add logs in batch
                addLogEntries(entries) {
                    if (!entries) return;
                    if (!this.logs) return;
                    entries.forEach((entry) => this.addLogEntry(entry));
                    this.renderLogs();
                },

                //render logs using clusterize.js
                renderLogs() {
                    if (!this.logs) return;
                    this.logs = this.logs.slice(-1000); //cap to 1000 items

                    if (this.logClusterize) {
                        //compute filtered rows
                        const rows = this.logs.filter(x => {
                            if (this.logFilterLevel == 1) return x.level !== "DEBUG" && x.level !== "TRACE";
                            if (this.logFilterLevel == 2) return x.level === "WARN" || x.level === "ERROR";
                            if (this.logFilterLevel == 3) return x.level === "ERROR";
                            return true;
                        }).map(log => log.content);

                        this.logClusterize.update(rows);
                        // Auto-scroll if not paused
                        if (!this.logPauseAutoScroll) this.$nextTick(() => {
                            this.logScrollArea.scrollTop = this.logScrollArea.scrollHeight;
                        });
                    }
                },

                //PLCVIEW
                setPlcPinmap(data) {
                    if (!data) return;
                    console.log("Setup PLC pinmap:", data);
                    const err_keys = ["HW_ERR", "FAULT", "FAULTY", "NG"];
                    this.plcInputs = data.filter(pin => pin.Function == 'DI').map(pin => ({ ...pin, isErr: err_keys.some(key => pin.Name.toUpperCase() === key), isManual: false, isActive: false }));
                    this.plcOutputs = data.filter(pin => pin.Function == 'DO').map(pin => ({ ...pin, isErr: err_keys.some(key => pin.Name.toUpperCase() === key), isManual: false, isActive: false }));
                },
                setInputPin(name, value) {
                    if (!this.readFlashTimeout) this.readFlashTimeout = setTimeout(() => { this.readFlashTimeout = null; }, 50);
                    const key = `DI.${name}`;
                    // console.log(`${key}: ${value}`);
                    const pinIndex = this.plcInputs.findIndex(pin => pin.Name === name);
                    if (pinIndex === -1) return;
                    const pin = this.plcInputs[pinIndex];
                    if (pin.isActive === value) return; //no change
                    pin.isActive = value;

                },
                setOutputPin(name, value) {
                    if (!this.writeFlashTimeout) this.writeFlashTimeout = setTimeout(() => { this.writeFlashTimeout = null; }, 50);
                    const key = `DO.${name}`;
                    // console.log(`${key}: ${value}`);
                    const pinIndex = this.plcOutputs.findIndex(pin => pin.Name === name);
                    if (pinIndex === -1) return;
                    const pin = this.plcOutputs[pinIndex];
                    if (pin.isActive === value) return; //no change
                    pin.isActive = value;
                },
                //input pin double click
                onInputPinDblClick(pin) {
                    console.log(`DI[${pin.Index}]-${pin.Name}`);
                    pin.isManual = true;
                    if (pin.manualTimer) clearTimeout(pin.manualTimer);
                    pin.manualTimer = setTimeout(() => { pin.isManual = false; pin.manualTimer = null; }, 500);
                    CSharpUtils.sendMessage({ type: 'input_pin_dblclick', value: pin.Name });
                },
                //output pin double click
                onOutputPinDblClick(pin) {
                    console.log(`DO[${pin.Index}]-${pin.Name}`);
                    pin.isManual = true;
                    if (pin.manualTimer) clearTimeout(pin.manualTimer);
                    pin.manualTimer = setTimeout(() => { pin.isManual = false; pin.manualTimer = null; }, 500);
                    CSharpUtils.sendMessage({ type: 'output_pin_dblclick', value: pin.Name });
                },

                //RESULT TABLE
                setResultTable(data) {
                    this.resultData = data;
                    // console.log("Set result table:", data);
                },

                //HISTORY TABLE
                initHistoryClusterize() {
                    if (this.historyClusterize) return;
                    this.historyClusterize = new Clusterize({
                        rows: [],
                        scrollId: 'history-clusterize-scroll',
                        contentId: 'history-clusterize-content'
                    });
                },
                //set history data
                setHistory(data) {
                    this.historyCols = data['cols'];
                    this.historyData = data['rows'];
                    this.renderHistoryTable();
                },

                //show row details on double click
                showRowDetails(row) {
                    CSharpUtils.sendMessage({ type: 'history_row_dblclick', value: row });
                },

                // Render history table using clusterize
                renderHistoryTable() {
                    if (!this.historyClusterize || !this.historyData) return;

                    const filteredData = this.showNGOnly
                        ? this.historyData.filter(row => row.res.toLowerCase() === 'ng')
                        : this.historyData;

                    const rows = filteredData.map(row =>
                        `<tr ondblclick="app.showRowDetails(${JSON.stringify(row).replace(/"/g, '&quot;')})">
                    <td>${row.time.split(' ')[1]}</td>
                    <td>${row.model}</td>
                    <td>${row.body}</td>
                    <td>${row.seq}</td>
                    <td class="res-text ${row.res.toLowerCase()}"><i class="fa ${row.res.toLowerCase() === 'ok' ? 'fa-check-circle' : 'fa-times-circle'}"></i></td>
                </tr>`
                    );

                    this.historyClusterize.update(rows);
                    this.historyScrollArea.scrollTop = 0;
                },

                setCounters(data) {
                    this.okCount = data?.ok || 0;
                    this.ngCount = data?.ng || 0;
                    this.renderPieChart();
                },

                //HOURLY CHART
                renderHourlyChart() {
                    if (this.crrTab == this.TAB.HISTORY) ChartUtils.renderHourlyChart('hourlyChart', this.hourlyData, false, this.showNGOnly);
                    else if (this.crrTab == this.TAB.ANALYTICS) ChartUtils.renderHourlyChart('analyticHourlyChart', this.hourlyData, true, this.showNGOnly);
                },

                //render pie chart
                renderPieChart() {
                    if (this.crrTab == this.TAB.ANALYTICS) ChartUtils.renderPieChart('analyticPieChart', this.okCount, this.ngCount);
                },

                //set hourly data for hourly chart
                setHourlyData(data) {
                    this.hourlyData = data;
                    // Initialize chart if not already done
                    this.renderHourlyChart();
                },

            },
            // Lifecycle hooks
            mounted() {
                console.log("------------REFRESH-------------");

                //load theme from localStorage
                const theme = localStorage.getItem('theme');
                if (theme == 'light') { document.body.setAttribute('data-theme', 'light'); }
                else { document.body.removeAttribute('data-theme'); }

                //load last active tab from localStorage
                const savedTab = localStorage.getItem('crrTab');
                if (savedTab) {
                    this.crrTab = parseInt(savedTab);
                }

                //setting up scroll area
                this.logScrollArea = document.getElementById('log-clusterize-scroll');
                function setUserScroll() {
                    this.logPauseAutoScroll = true;
                    clearTimeout(this.logInteractTimeout);
                    this.logInteractTimeout = setTimeout(() => {
                        this.logPauseAutoScroll = false;
                    }, 3000);
                }

                if (this.logScrollArea) {

                    this.logScrollArea.addEventListener('wheel', () => { setUserScroll.call(this); });
                    this.logScrollArea.addEventListener('mousedown', () => { setUserScroll.call(this); });
                    this.logScrollArea.addEventListener('touchstart', () => { setUserScroll.call(this); });

                    this.logScrollArea.addEventListener('scroll', () => {
                        if (this.logPauseAutoScroll) return;
                        this.logScrollArea.scrollTop = this.logScrollArea.scrollHeight;
                    });
                }

                this.initLogClusterize();

                //setting up history table
                this.historyScrollArea = document.getElementById('history-clusterize-scroll');
                this.initHistoryClusterize();

                API.init();

                // Render initial empty chart
                window.addEventListener('resize', () => {
                    this.renderHourlyChart();
                    this.renderPieChart();
                });
                this.renderHourlyChart();
                this.renderPieChart();
                this.renderLogs();

                // Disable right-click context menu
                document.addEventListener('contextmenu', event => event.preventDefault());
            },
            watch: {
                //when crrTab changes, initialize clusterize and render chart/table if needed
                crrTab(newVal) {
                    if (newVal === this.TAB.HISTORY) {
                        this.$nextTick(() => {
                            this.initHistoryClusterize();
                            this.renderHourlyChart();
                            this.renderHistoryTable();
                        });
                    }
                    else if (newVal === this.TAB.LOG) {
                        this.$nextTick(() => { this.initLogClusterize(); this.renderLogs(); });
                    }
                    else if (newVal === this.TAB.ANALYTICS) {
                        this.$nextTick(() => { this.renderHourlyChart(); this.renderPieChart(); });
                    }
                },
                //when showNGOnly changes, re-render chart and history table
                showNGOnly(newVal) {
                    this.$nextTick(() => {
                        clearTimeout(this.showNGOnlyTimeout);
                        this.showNGOnlyTimeout = setTimeout(() => { this.showNGOnly = false; }, 5000);
                        this.renderHourlyChart();
                        this.renderHistoryTable();
                    });
                },
                //when logFilterLevel changes, re-render logs
                logFilterLevel(newVal) {
                    if (newVal != 1) {
                        clearTimeout(this.logFilterTimeout);
                        this.logFilterTimeout = setTimeout(() => { this.logFilterLevel = 1; }, 10000);
                    }
                    this.renderLogs();
                    this.logPauseAutoScroll = false;
                    this.logScrollArea.scrollTop = this.logScrollArea.scrollHeight;
                },
                debugCnt(newVal) {
                    const dt = performance.now() - this.debugT0;
                    this.debugT0 = performance.now();
                    if (dt > 500) { this.debugCnt = 0; }
                    if (this.debugCnt > 5) {
                        this.debugCnt = 0;
                        console.log("Debug mode activated");
                        CSharpUtils.sendMessage({ type: 'open_dev_tool' });
                    }
                }
            },
        }).mount("#app");
        window.app = app; //expose app to global for api calls
        console.log("App mounted");
    </script>

</body>

</html>